{"version":3,"sources":["worker/BodyPix.worker.ts","container/StateContainer.ts","components/InputVideo.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Worker","createContainer","useState","fileUrl","setFileUrl","phase","value","progress","setProgress","setProgressValue","incrementProgressPhase","resetProgress","onChange","e","setFilename","state","file","files","target","item","name","prevFileUrl","URL","revokeObjectURL","createObjectURL","recreateFileUrl","InputVideo","StateContainer","useContainer","filename","disabled","className","htmlFor","Button","variant","component","FolderOpen","id","type","accept","THESHOLDS","exec","async","$video","$output","readyState","Promise","resolve","oncanplay","imgb","createImageBitmap","width","height","innerHTML","$canvas","document","createElement","appendChild","console","log","duration","output","transferControlToOffscreen","bodyPix","config","outputCanvas","WrappedBodyPix","wrap","BodyPixWorkerAbstract","init","transfer","getBodyPix","theshold","currentTime","imageb","apply","warn","App","useRef","Paper","Typography","Grid","container","direction","justify","alignItems","spacing","color","onClick","current","KeyboardArrowRight","CircularProgress","size","xs","LinearProgress","toFixed","src","controls","ref","Boolean","window","location","hostname","match","ReactDOM","render","Provider","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.02d9c55e.chunk.js","sourcesContent":["module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"688595e44a75f9582905.worker.js\");\n};","import { createContainer } from 'unstated-next'\nimport { useState } from 'react'\n\ninterface Progress {\n  phase: number\n  value: number\n}\n\nexport default createContainer(() => {\n  const [fileUrl, setFileUrl] = useState('')\n  const [progress, setProgress] = useState<Progress>({\n    phase: 0,\n    value: 0\n  })\n\n  const setProgressValue = (value: number) =>\n    setProgress(progress => ({ ...progress, value }))\n  const incrementProgressPhase = () =>\n    setProgress(progress => ({ ...progress, phase: progress.phase + 1 }))\n  const resetProgress = () => setProgress({ phase: 0, value: 0 })\n\n  return {\n    fileUrl,\n    setFileUrl,\n    progress,\n    setProgressValue,\n    incrementProgressPhase,\n    resetProgress\n  }\n})\n","import React, { FC, useState, ChangeEvent, Dispatch } from 'react'\nimport StateContainer from '../container/StateContainer'\nimport { Button } from '@material-ui/core'\nimport { FolderOpen } from '@material-ui/icons'\n\nconst NO_FILE = '選択されていません'\n\nconst recreateFileUrl = (\n  setFileUrl: Dispatch<string>,\n  file: File | null,\n  prevFileUrl: string\n) => {\n  if (prevFileUrl !== '') {\n    URL.revokeObjectURL(prevFileUrl)\n  }\n  setFileUrl(file ? URL.createObjectURL(file) : '')\n}\n\nconst onChange = (\n  e: ChangeEvent<HTMLInputElement>,\n  setFilename: Dispatch<string>,\n  state: ReturnType<typeof StateContainer.useContainer>\n) => {\n  let file = null\n  const { files } = e.target\n  if (files) {\n    file = files.item(0)\n    if (file) {\n      setFilename(file.name)\n    }\n  }\n  if (file == null) {\n    setFilename(NO_FILE)\n  }\n  recreateFileUrl(state.setFileUrl, file, state.fileUrl)\n}\n\nconst InputVideo: FC<{}> = () => {\n  const state = StateContainer.useContainer()\n  const [filename, setFilename] = useState(NO_FILE)\n\n  const disabled = state.progress.value > 0\n\n  return (\n    <div className=\"input-video\">\n      <label htmlFor=\"input-file-dom\">\n        <Button variant=\"contained\" component=\"span\" disabled={disabled}>\n          <FolderOpen />\n          ファイルを選択: <span className=\"filename\">{filename}</span>\n        </Button>\n      </label>\n      <input\n        id=\"input-file-dom\"\n        type=\"file\"\n        accept=\"video/*\"\n        disabled={disabled}\n        onChange={e => onChange(e, setFilename, state)}\n      />\n    </div>\n  )\n}\n\nexport default InputVideo\n","import React, { FC, useRef } from 'react'\nimport './App.sass'\nimport InputVideo from './InputVideo'\nimport StateContainer from '../container/StateContainer'\n\nimport {\n  Paper,\n  Grid,\n  Typography,\n  Button,\n  CircularProgress,\n  LinearProgress\n} from '@material-ui/core'\nimport { KeyboardArrowRight } from '@material-ui/icons'\n\nimport BodyPixWorkerAbstract, {\n  BodyPixWorker,\n  Config\n} from '../worker/BodyPix.worker'\nimport { wrap, transfer } from 'comlink'\n\nconst THESHOLDS = [0.05, 0.1, 0.2, 0.3, 0.5, 0.8, 1.0]\n\nconst getBodyPix = async (config: Config, outputCanvas: OffscreenCanvas) => {\n  const WrappedBodyPix = wrap<typeof BodyPixWorker>(new BodyPixWorkerAbstract())\n  const bodyPix = await new WrappedBodyPix()\n  await bodyPix.init(\n    config,\n    transfer(outputCanvas, [(outputCanvas as unknown) as Transferable])\n  )\n  return bodyPix\n}\n\nconst exec = async (\n  $video: HTMLVideoElement,\n  $output: HTMLDivElement,\n  state: ReturnType<typeof StateContainer.useContainer>\n) => {\n  if ($video.readyState < 3) {\n    await new Promise(resolve => {\n      $video.oncanplay = resolve\n    })\n  }\n  const imgb = await createImageBitmap($video)\n  const { width, height } = imgb\n\n  $output.innerHTML = ''\n  const $canvas = document.createElement('canvas')\n  $canvas.width = width\n  $canvas.height = height\n  $output.appendChild($canvas)\n  console.log(width, height)\n\n  const { duration } = $video\n  const output = $canvas.transferControlToOffscreen()\n\n  const bodyPix = await getBodyPix(\n    {\n      width,\n      height\n    },\n    output\n  )\n\n  for (const theshold of THESHOLDS) {\n    console.log(`start THESHOLD: ${theshold}`)\n    $video.currentTime = 0\n    state.incrementProgressPhase()\n    while ($video.currentTime < duration) {\n      if ($video.readyState < 3) {\n        await new Promise(resolve => {\n          $video.oncanplay = resolve\n        })\n      }\n      try {\n        const imageb = await createImageBitmap($video)\n        const progress = await bodyPix.apply(\n          transfer(imageb, [imageb]),\n          theshold\n        )\n        if (progress === -1) return\n        console.log((progress / (width * height)) * 100)\n        state.setProgressValue((progress / (width * height)) * 100)\n      } catch (e) {\n        console.warn(e)\n      }\n      $video.currentTime += 1\n    }\n  }\n}\n\nconst App: FC = () => {\n  const state = StateContainer.useContainer()\n\n  const $video = useRef<HTMLVideoElement>(null)\n  const $output = useRef<HTMLDivElement>(null)\n\n  return (\n    <Paper id=\"app\">\n      <Typography variant=\"h5\" component=\"h1\">\n        Extract background\n      </Typography>\n      <Typography component=\"p\">\n        動画から人物(一人に限る)を取り除いた背景を抽出します。\n        定点からの映像でしか正常に動作しません。\n        また、Chromeでしか動作しません。\n        快適な動作にはそこそこのスペックを要求します。\n      </Typography>\n      <Grid\n        container\n        direction=\"row\"\n        justify=\"flex-start\"\n        alignItems=\"flex-start\"\n        spacing={1}\n      >\n        <Grid item>\n          <InputVideo />\n        </Grid>\n        <Grid item>\n          <Button\n            variant=\"contained\"\n            color=\"primary\"\n            disabled={state.fileUrl === '' || state.progress.phase !== 0}\n            onClick={async () => {\n              if ($video.current && $output.current) {\n                await exec($video.current, $output.current, state)\n                state.resetProgress()\n              }\n            }}\n          >\n            開始\n            <KeyboardArrowRight />\n            {state.progress.phase !== 0 && (\n              <CircularProgress size={24} className=\"button-loading\" />\n            )}\n          </Button>\n        </Grid>\n      </Grid>\n      <Grid\n        container\n        direction=\"row\"\n        justify=\"flex-start\"\n        alignItems=\"center\"\n        spacing={1}\n      >\n        <Grid item xs>\n          <LinearProgress variant=\"determinate\" value={state.progress.value} />\n        </Grid>\n        <Grid item>{state.progress.value.toFixed(4)}%</Grid>\n      </Grid>\n      <video id=\"input\" src={state.fileUrl} controls ref={$video} />\n      <div id=\"output\" ref={$output}></div>\n    </Paper>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.sass'\nimport App from './components/App'\nimport StateContainer from './container/StateContainer'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(\n  <StateContainer.Provider>\n    <App />\n  </StateContainer.Provider>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}